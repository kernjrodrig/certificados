---
# Playbook para reemplazo manual de certificados TLS en OpenShift
# Automatiza los pasos de creación de Secret, actualización de IngressController y reinicio de pods

- name: Reemplazo Manual de Certificados TLS en OpenShift
  hosts: localhost
  connection: local
  gather_facts: false
  become: false
  vars:
    # Paso 1: Configurar variables de entorno
    cert_path: "/home/javo/Documents/certificados/certs/cluster1-cert.pem"
    key_path: "/home/javo/Documents/certificados/certs/cluster1-key.pem"
    secret_name: "ingress-tls-secret-30d"
    
    # Configuración del cluster
    cluster_api_url: "https://api.cluster-l8wf6.dynamic.redhatworkshops.io:6443"
    cluster_token: "sha256~c9-OlPpyzxuNt2lI0TrW0Z07WadjPTfmhG727nY-beI"
    
    # Namespaces
    ingress_namespace: "openshift-ingress"
    ingress_operator_namespace: "openshift-ingress-operator"
    ingress_controller_name: "default"
    
  tasks:
    - name: Paso 1 - Mostrar configuración de variables
      ansible.builtin.debug:
        msg: |
          Configuración:
          - Certificado: {{ cert_path }}
          - Clave: {{ key_path }}
          - Secret: {{ secret_name }}
          - Cluster: {{ cluster_api_url }}

    - name: Paso 2 - Verificar que los archivos de certificado existen
      ansible.builtin.stat:
        path: "{{ item }}"
      register: cert_files
      loop:
        - "{{ cert_path }}"
        - "{{ key_path }}"

    - name: Fallar si algún archivo no existe
      ansible.builtin.fail:
        msg: "El archivo {{ item.item }} no existe"
      when: not item.stat.exists
      loop: "{{ cert_files.results }}"

    - name: Paso 3 - Crear/Actualizar Secret TLS
      kubernetes.core.k8s:
        host: "{{ cluster_api_url }}"
        api_key: "{{ cluster_token }}"
        state: present
        validate_certs: false
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: "{{ secret_name }}"
            namespace: "{{ ingress_namespace }}"
          type: kubernetes.io/tls
          data:
            tls.crt: "{{ lookup('file', cert_path) | b64encode }}"
            tls.key: "{{ lookup('file', key_path) | b64encode }}"
      register: secret_result
      no_log: true

    - name: Mostrar resultado de creación del Secret
      ansible.builtin.debug:
        msg: "Secret {{ secret_name }} creado/actualizado exitosamente en {{ ingress_namespace }}"

    - name: Paso 4 - Actualizar IngressController con el nuevo certificado
      kubernetes.core.k8s:
        host: "{{ cluster_api_url }}"
        api_key: "{{ cluster_token }}"
        state: present
        kind: IngressController
        api_version: operator.openshift.io/v1
        name: "{{ ingress_controller_name }}"
        namespace: "{{ ingress_operator_namespace }}"
        validate_certs: false
        definition:
          spec:
            defaultCertificate:
              name: "{{ secret_name }}"
      register: ingress_update_result
      no_log: true

    - name: Mostrar resultado de actualización del IngressController
      ansible.builtin.debug:
        msg: "IngressController {{ ingress_controller_name }} actualizado con el secret {{ secret_name }}"

    - name: Paso 5 - Reiniciar deployment del router
      kubernetes.core.k8s:
        host: "{{ cluster_api_url }}"
        api_key: "{{ cluster_token }}"
        state: absent
        api_version: apps/v1
        kind: Pod
        namespace: "{{ ingress_namespace }}"
        label_selectors:
          - "ingresscontroller.operator.openshift.io/deployment-ingresscontroller={{ ingress_controller_name }}"
      register: router_restart_result
      no_log: true

    - name: Mostrar resultado del reinicio de pods
      ansible.builtin.debug:
        msg: "Pods del router reiniciados para aplicar el nuevo certificado"

    - name: Paso 6 - Esperar a que los pods estén listos
      kubernetes.core.k8s_info:
        host: "{{ cluster_api_url }}"
        api_key: "{{ cluster_token }}"
        api_version: apps/v1
        kind: Pod
        namespace: "{{ ingress_namespace }}"
        label_selectors:
          - "ingresscontroller.operator.openshift.io/deployment-ingresscontroller={{ ingress_controller_name }}"
        validate_certs: false
      register: pods_status
      until: pods_status.resources | selectattr('status.phase', 'equalto', 'Running') | list | length > 0
      retries: 30
      delay: 10
      no_log: true

    - name: Paso 7 - Consultar fecha de vencimiento del certificado
      kubernetes.core.k8s_info:
        host: "{{ cluster_api_url }}"
        api_key: "{{ cluster_token }}"
        api_version: v1
        kind: Secret
        name: "{{ secret_name }}"
        namespace: "{{ ingress_namespace }}"
        validate_certs: false
      register: secret_info
      no_log: true

    - name: Extraer certificado del Secret y obtener fecha de vencimiento
      ansible.builtin.shell: |
        echo "{{ secret_info.resources[0].data['tls.crt'] }}" | base64 -d | openssl x509 -noout -enddate
      register: cert_enddate
      changed_when: false

    - name: Mostrar fecha de vencimiento del certificado
      ansible.builtin.debug:
        msg: "Fecha de vencimiento del certificado: {{ cert_enddate.stdout }}"

    - name: Paso 8 - Verificar que el certificado está activo
      ansible.builtin.shell: |
        echo "{{ secret_info.resources[0].data['tls.crt'] }}" | base64 -d | openssl x509 -noout -subject -issuer
      register: cert_details
      changed_when: false

    - name: Mostrar detalles del certificado activo
      ansible.builtin.debug:
        msg: |
          Certificado activo:
          {{ cert_details.stdout }}

    - name: Resumen final
      ansible.builtin.debug:
        msg: |
          ✅ Reemplazo de certificado completado exitosamente:
          - Secret: {{ secret_name }} en {{ ingress_namespace }}
          - IngressController: {{ ingress_controller_name }} actualizado
          - Pods del router: reiniciados y funcionando
          - Certificado: {{ cert_enddate.stdout }}