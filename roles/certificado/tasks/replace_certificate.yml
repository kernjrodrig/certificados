---
# Tareas para reemplazar certificados de OpenShift
# Este archivo se incluye cuando un certificado expira en menos de 60 d√≠as

- name: Obtener secreto TLS actual para backup antes del reemplazo
  kubernetes.core.k8s_info:
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    api_version: v1
    kind: Secret
    name: "{{ cluster.secret_name }}"
    namespace: "{{ cluster.namespace_ingress }}"
    verify_ssl: false
  register: current_secret_backup
  no_log: false

- name: Crear directorio de backup si no existe
  ansible.builtin.file:
    path: "{{ cluster.backup_file | dirname }}"
    state: directory
    mode: '0700'
  when: cluster.backup_file is defined and cluster.backup_file != ""

- name: Guardar backup completo del secreto antes del reemplazo
  ansible.builtin.copy:
    content: "{{ current_secret_backup.resources[0] | to_nice_yaml }}"
    dest: "{{ cluster.backup_file }}"
    mode: "{{ certificate.backup_file_mode | default('0600') }}"
  when: 
    - current_secret_backup.resources | length > 0
    - cluster.backup_file is defined
    - cluster.backup_file != ""
  register: backup_result

- name: Mostrar informaci√≥n del backup realizado
  ansible.builtin.debug:
    msg:
      - "üíæ Backup del secreto guardado exitosamente"
      - "üìÅ Ubicaci√≥n: {{ cluster.backup_file }}"
      - "üìã Secreto: {{ cluster.secret_name }} en namespace {{ cluster.namespace_ingress }}"
      - "‚è∞ Backup creado antes del reemplazo del certificado"
  when: backup_result is defined and backup_result.changed

- name: Obtener fecha actual en formato YYYYMMDD
  ansible.builtin.set_fact:
    current_date: "{{ ansible_date_time.date | replace('-', '') }}"
  when: ansible_date_time is defined

- name: Obtener fecha actual en formato YYYYMMDD (fallback)
  ansible.builtin.set_fact:
    current_date: "{{ lookup('pipe', 'date +%Y%m%d') }}"
  when: ansible_date_time is not defined

- name: Definir nombres de recursos con fecha
  ansible.builtin.set_fact:
    configmap_name: "{{ cluster.configmap_name_prefix | default('custom-ca') }}-{{ current_date }}"
    secret_name_with_date: "{{ cluster.secret_name_prefix | default('router-certs') }}-{{ current_date }}"

- name: Verificar existencia de archivos de certificados
  ansible.builtin.stat:
    path: "{{ item }}"
  register: cert_files_stat
  loop:
    - "{{ cluster.cert_file_crt }}"
    - "{{ cluster.ca_intermedia_file }}"
    - "{{ cluster.ca_raiz_file }}"
  failed_when: false

- name: Validar que todos los archivos de certificados existen
  ansible.builtin.fail:
    msg: "El archivo {{ item.item }} no existe. Verifica la ruta en vars.yml"
  loop: "{{ cert_files_stat.results }}"
  when: not item.stat.exists

- name: Leer contenido de los certificados individuales
  ansible.builtin.slurp:
    src: "{{ item }}"
  register: cert_contents
  loop:
    - "{{ cluster.cert_file_crt }}"
    - "{{ cluster.ca_intermedia_file }}"
    - "{{ cluster.ca_raiz_file }}"
  loop_control:
    label: "{{ item | basename }}"

- name: Unir certificados (servidor + CA intermedia + CA ra√≠z) en archivo .pem
  ansible.builtin.copy:
    content: "{{ cert_contents.results | map(attribute='content') | map('b64decode') | join('') }}"
    dest: "{{ cluster.cert_file_combined }}"
    mode: '0600'
  register: combine_certs_result

- name: Mostrar informaci√≥n de certificados combinados
  ansible.builtin.debug:
    msg:
      - "üîó Certificados combinados exitosamente"
      - "   Certificado servidor: {{ cluster.cert_file_crt }}"
      - "   CA Intermedia: {{ cluster.ca_intermedia_file }}"
      - "   CA Ra√≠z: {{ cluster.ca_raiz_file }}"
      - "   Archivo combinado: {{ cluster.cert_file_combined }}"

- name: Validar el nuevo certificado combinado antes de actualizar
  community.crypto.x509_certificate_info:
    path: "{{ cluster.cert_file_combined }}"
  register: new_cert_info
  failed_when: new_cert_info.not_after is not defined

- name: Leer contenido del archivo combinado para validar entidades certificantes
  ansible.builtin.slurp:
    src: "{{ cluster.cert_file_combined }}"
  register: combined_cert_content

- name: Contar certificados en el archivo combinado
  ansible.builtin.set_fact:
    cert_count: "{{ (combined_cert_content.content | b64decode | regex_findall('-----BEGIN CERTIFICATE-----') | length) | int }}"

- name: Validar que hay al menos 3 certificados (servidor + intermedia + ra√≠z)
  ansible.builtin.fail:
    msg: "Se esperaban al menos 3 certificados (servidor + CA intermedia + CA ra√≠z), se encontraron {{ cert_count }}"
  when: cert_count | int < 3

- name: Obtener informaci√≥n del primer certificado (servidor) para validaci√≥n
  community.crypto.x509_certificate_info:
    path: "{{ cluster.cert_file_combined }}"
  register: first_cert_info

- name: Mostrar informaci√≥n de la cadena de certificados validada
  ansible.builtin.debug:
    msg:
      - "‚úÖ Cadena de certificados validada correctamente"
      - "   Certificados encontrados: {{ cert_count }}"
      - "   Primer certificado (servidor):"
      - "     Subject: {{ first_cert_info.subject }}"
      - "     Issuer: {{ first_cert_info.issuer }}"

- name: Calcular d√≠as restantes del nuevo certificado
  ansible.builtin.set_fact:
    new_cert_days_remaining: "{{ (((new_cert_info.not_after | to_datetime('%Y%m%d%H%M%SZ')).timestamp() | int) - (current_timestamp | int)) // 86400 | int }}"
  when: new_cert_info.not_after is defined

- name: Formatear fechas del nuevo certificado
  ansible.builtin.set_fact:
    new_cert_valid_from: "{{ (new_cert_info.not_before | to_datetime('%Y%m%d%H%M%SZ')).strftime('%d/%m/%Y %H:%M:%S UTC') }}"
    new_cert_valid_until: "{{ (new_cert_info.not_after | to_datetime('%Y%m%d%H%M%SZ')).strftime('%d/%m/%Y %H:%M:%S UTC') }}"
  when: new_cert_info.not_after is defined

- name: Mostrar informaci√≥n del certificado a aplicar
  ansible.builtin.debug:
    msg:
      - "üìã Informaci√≥n del certificado a aplicar:"
      - "   Subject: {{ new_cert_info.subject }}"
      - "   Issuer: {{ new_cert_info.issuer }}"
      - "   V√°lido desde: {{ new_cert_valid_from }}"
      - "   V√°lido hasta: {{ new_cert_valid_until }}"
      - "   üìä D√≠as restantes: {{ new_cert_days_remaining }}"
  when: new_cert_info.not_after is defined

- name: Validar que el nuevo certificado no est√© vencido
  ansible.builtin.fail:
    msg: "El nuevo certificado {{ cluster.cert_file_combined }} ya est√° vencido."
  when: new_cert_info.not_after is defined and (new_cert_info.not_after | to_datetime('%Y%m%d%H%M%SZ')).timestamp() | int < (current_timestamp | int)

- name: Validar que el nuevo certificado sea v√°lido por al menos {{ certificate.min_validity_days | default(30) }} d√≠as
  ansible.builtin.fail:
    msg: "El nuevo certificado {{ cluster.cert_file_combined }} debe ser v√°lido por al menos {{ certificate.min_validity_days | default(30) }} d√≠as."
  when: new_cert_info.not_after is defined and ((new_cert_info.not_after | to_datetime('%Y%m%d%H%M%SZ')).timestamp() | int - (current_timestamp | int)) < ((certificate.min_validity_days | default(30) | int) * 24 * 3600)

- name: Verificar que la llave privada existe
  ansible.builtin.stat:
    path: "{{ cluster.key_file_new }}"
  register: key_file_stat

- name: Validar existencia de la llave privada
  ansible.builtin.fail:
    msg: "La llave privada {{ cluster.key_file_new }} no existe."
  when: not key_file_stat.stat.exists

- name: Obtener informaci√≥n del certificado para validar correspondencia con llave
  community.crypto.x509_certificate_info:
    path: "{{ cluster.cert_file_combined }}"
  register: cert_info_for_match

- name: Obtener informaci√≥n de la llave privada
  community.crypto.openssl_privatekey_info:
    path: "{{ cluster.key_file_new }}"
  register: key_info_for_match

- name: Validar correspondencia usando fingerprints SHA256 (m√©todo principal y m√°s confiable)
  ansible.builtin.assert:
    that:
      - cert_info_for_match.public_key_fingerprints is defined
      - cert_info_for_match.public_key_fingerprints.sha256 is defined
      - key_info_for_match.public_key_fingerprints is defined
      - key_info_for_match.public_key_fingerprints.sha256 is defined
      - cert_info_for_match.public_key_fingerprints.sha256 == key_info_for_match.public_key_fingerprints.sha256
    fail_msg: "El certificado {{ cluster.cert_file_combined }} y la llave {{ cluster.key_file_new }} NO corresponden. Los fingerprints SHA256 no coinciden (Cert: {{ cert_info_for_match.public_key_fingerprints.sha256 | default('N/A') }}, Key: {{ key_info_for_match.public_key_fingerprints.sha256 | default('N/A') }})."
    success_msg: "‚úÖ Validaci√≥n: Certificado y llave privada CORRESPONDEN (fingerprints SHA256 coinciden)."
  when:
    - cert_info_for_match.public_key_fingerprints is defined
    - cert_info_for_match.public_key_fingerprints.sha256 is defined
    - key_info_for_match.public_key_fingerprints is defined
    - key_info_for_match.public_key_fingerprints.sha256 is defined

- name: Advertencia si no se pueden validar fingerprints - usar validaci√≥n alternativa
  ansible.builtin.debug:
    msg:
      - "‚ö†Ô∏è  Advertencia: No se pudieron obtener fingerprints SHA256 para validar correspondencia"
      - "   Se asume que el certificado y la llave corresponden bas√°ndose en la validaci√≥n del certificado"
      - "   Certificado: {{ cluster.cert_file_combined }}"
      - "   Llave: {{ cluster.key_file_new }}"
      - "   Nota: La correspondencia se validar√° al crear el Secret TLS en Kubernetes"
  when:
    - cert_info_for_match.public_key_fingerprints is not defined or cert_info_for_match.public_key_fingerprints.sha256 is not defined
    - key_info_for_match.public_key_fingerprints is not defined or key_info_for_match.public_key_fingerprints.sha256 is not defined

- name: Mostrar resultado de validaci√≥n certificado-llave
  ansible.builtin.debug:
    msg:
      - "‚úÖ Validaci√≥n: Certificado y llave privada CORRESPONDEN"
      - "   El certificado {{ cluster.cert_file_combined }} y la llave {{ cluster.key_file_new }} son compatibles"
      - "   {{ 'Fingerprint SHA256: ' + cert_info_for_match.public_key_fingerprints.sha256 if (cert_info_for_match.public_key_fingerprints is defined and cert_info_for_match.public_key_fingerprints.sha256 is defined) else 'Fingerprint SHA256: No disponible' }}"
  when:
    - cert_info_for_match.public_key_fingerprints is defined
    - cert_info_for_match.public_key_fingerprints.sha256 is defined

- name: Analizar cadena de certificados en el archivo combinado
  ansible.builtin.set_fact:
    cert_chain_info: "{{ cert_count | default(0) | int }}"
    has_chain: "{{ (cert_count | default(0) | int) >= 3 }}"

- name: Mostrar informaci√≥n de la cadena de certificados
  ansible.builtin.debug:
    msg:
      - "   An√°lisis de cadena de certificados:"
      - "   Certificados encontrados en el archivo: {{ cert_chain_info }}"
      - "   ‚úÖ Cadena completa detectada (certificado servidor + CA intermedia + CA ra√≠z)"
  when: cert_chain_info is defined

- name: Obtener ConfigMap existente (si existe) para preservar configuraci√≥n
  kubernetes.core.k8s_info:
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    api_version: v1
    kind: ConfigMap
    name: "{{ configmap_name }}"
    namespace: openshift-config
    verify_ssl: false
  register: existing_configmap
  failed_when: false
  changed_when: false

- name: Preparar datos del ConfigMap preservando configuraci√≥n existente
  ansible.builtin.set_fact:
    configmap_data: >-
      {{
        (existing_configmap.resources[0].data | default({}))
        | combine({(configmap_name + '.pem'): lookup('file', cluster.cert_file_combined)})
      }}
  when: existing_configmap.resources | length > 0

- name: Preparar datos del ConfigMap para creaci√≥n nueva
  ansible.builtin.set_fact:
    configmap_data: >-
      {{
        {(configmap_name + '.pem'): lookup('file', cluster.cert_file_combined)}
      }}
  when: existing_configmap.resources | length == 0

- name: Preparar metadata del ConfigMap preservando labels y annotations existentes (si existe)
  ansible.builtin.set_fact:
    configmap_metadata:
      name: "{{ configmap_name }}"
      namespace: openshift-config
      labels: "{{ existing_configmap.resources[0].metadata.labels | default({}) }}"
      annotations: "{{ existing_configmap.resources[0].metadata.annotations | default({}) }}"
  when: existing_configmap.resources | length > 0

- name: Preparar metadata del ConfigMap para creaci√≥n nueva
  ansible.builtin.set_fact:
    configmap_metadata:
      name: "{{ configmap_name }}"
      namespace: openshift-config
  when: existing_configmap.resources | length == 0

- name: Crear o actualizar ConfigMap con el certificado combinado preservando configuraci√≥n existente
  kubernetes.core.k8s:
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    state: present
    validate_certs: false
    definition:
      apiVersion: v1
      kind: ConfigMap
      metadata: "{{ configmap_metadata }}"
      data: "{{ configmap_data }}"
  register: configmap_result

- name: Mostrar informaci√≥n del ConfigMap creado o actualizado
  ansible.builtin.debug:
    msg:
      - "üì¶ ConfigMap {{ 'actualizado' if existing_configmap.resources | length > 0 else 'creado' }} exitosamente"
      - "   Nombre: {{ configmap_name }}"
      - "   Namespace: openshift-config"
      - "   Archivo: {{ configmap_name }}.pem"
      - "   {{ '‚úÖ Configuraci√≥n existente preservada' if existing_configmap.resources | length > 0 else 'üÜï ConfigMap nuevo creado' }}"
  when: configmap_result is defined

- name: Aplicar patch al proxy/cluster para usar la CA personalizada
  kubernetes.core.k8s:
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    state: present
    validate_certs: false
    definition:
      apiVersion: config.openshift.io/v1
      kind: Proxy
      metadata:
        name: cluster
      spec:
        trustedCA:
          name: "{{ configmap_name }}"
  register: proxy_patch_result

- name: Mostrar informaci√≥n del patch aplicado al proxy
  ansible.builtin.debug:
    msg:
      - " => Patch aplicado al proxy/cluster"
      - "   ConfigMap de CA personalizada: {{ configmap_name }}"
      - "   El cluster ahora conf√≠a en la CA personalizada"
  when: proxy_patch_result is defined

- name: Crear secreto TLS para el certificado de ingreso con nombre que incluye fecha
  kubernetes.core.k8s:
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    state: present
    validate_certs: false
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: "{{ secret_name_with_date }}"
        namespace: "{{ cluster.namespace_ingress }}"
      type: kubernetes.io/tls
      data:
        tls.crt: "{{ lookup('file', cluster.cert_file_combined) | b64encode }}"
        tls.key: "{{ lookup('file', cluster.key_file_new) | b64encode }}"
  register: secret_result

- name: Verificar existencia del secreto
  kubernetes.core.k8s_info:
    kind: Secret
    name: "{{ secret_name_with_date }}"
    namespace: "{{ cluster.namespace_ingress }}"
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    validate_certs: false
  register: secret_check
  failed_when: secret_check.resources | length == 0

- name: Mostrar resultado de la verificaci√≥n del secreto
  ansible.builtin.debug:
    msg:
      - "‚úÖ Secreto TLS creado exitosamente"
      - "   Nombre: {{ secret_name_with_date }}"
      - "   Namespace: {{ cluster.namespace_ingress }}"
      - "   Certificado: {{ cluster.cert_file_combined }}"
      - "   Llave: {{ cluster.key_file_new }}"

- name: Obtener informaci√≥n del Ingress Controller
  kubernetes.core.k8s_info:
    kind: IngressController
    api_version: operator.openshift.io/v1
    name: "{{ cluster.ingress_controller_name | default('default') }}"
    namespace: "{{ cluster.namespace_ingress_operator | default('openshift-ingress-operator') }}"
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    validate_certs: false
  register: ingress_controller_info

- name: Actualizar Ingress Controller con el certificado que incluye fecha
  kubernetes.core.k8s:
    state: present
    kind: IngressController
    api_version: operator.openshift.io/v1
    name: "{{ cluster.ingress_controller_name | default('default') }}"
    namespace: "{{ cluster.namespace_ingress_operator | default('openshift-ingress-operator') }}"
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    validate_certs: false
    definition:
      spec:
        defaultCertificate:
          name: "{{ secret_name_with_date }}"
  register: ingress_update_result

- name: Mostrar resultado de la actualizaci√≥n del Ingress Controller
  ansible.builtin.debug:
    msg:
      - "‚úÖ Ingress Controller actualizado exitosamente"
      - "   Nombre: {{ cluster.ingress_controller_name | default('default') }}"
      - "   Namespace: {{ cluster.namespace_ingress_operator | default('openshift-ingress-operator') }}"
      - "   Secret TLS: {{ secret_name_with_date }}"
      - "   Fecha de aplicaci√≥n: {{ current_date }}"

- name: Obtener informaci√≥n del recurso ingresses.config/cluster
  kubernetes.core.k8s_info:
    api_version: config.openshift.io/v1
    kind: Ingress
    name: "cluster"
    host: "{{ cluster.api_url }}"
    api_key: "{{ cluster.token }}"
    validate_certs: false
  register: ingress_config_info

- name: Guardar dominio en una variable
  ansible.builtin.set_fact:
    cluster_domain_name: "{{ ingress_config_info.resources[0].spec.domain }}"

- name: Mostrar dominio del cl√∫ster
  ansible.builtin.debug:
    msg: "Dominio del cl√∫ster: {{ cluster_domain_name }}"